function maximumSum(numbers, k) {
  let currSum = 0;
  let start = 0;
  let end = 0;

  // first k sum
  for (; end < k; end++) {
    currSum += numbers[end];
  }

  let max = currSum;
  let maxStart = start;

  for (; end < numbers.length; end++) {
    currSum += numbers[end] - numbers[start];
    start++;
    if (max < currSum) {
      max = currSum;
      maxStart = start;
    }
  }

  return [max, maxStart];
}

// Example usage:
console.log(maximumSum([2, 1, 5, 1, 3, 2], 3)); // Expected output: [9, 2]
console.log(maximumSum([2, 1, 5, 1, 3, 2], 2)); // Expected output: [6, 1]

/*
Given an array of integers and an integer k (the length of a subarray),
find the subarray of length k that has the maximum sum using the two-pointer technique.

The function maximumSum should take an array numbers and an integer k as inputs,
and return an array with two values: the largest sum of a k-length subarray and the index of the first element of this subarray. If multiple subarrays yield the same maximum sum, return the one with the lowest starting index.

The solution should have a linear time complexity, i.e., O(n), where n is the number of elements in the numbers array.

For example, in maximumSum([2, 1, 5, 1, 3, 2], 3), when k = 3,
the subarrays are [2, 1, 5], [1, 5, 1], [5, 1, 3], and [1, 3, 2]. The maximum sum among these is 9, generated by the subarray [5, 1, 3]. The function's output should be [9, 2].

If k = 2, as in maximumSum([2, 1, 5, 1, 3, 2], 2),
the subarrays are [2, 1], [1, 5], [5, 1], [1, 3], and [3, 2].
The maximum sum among these is 6, generated by the subarray [1, 5]. The output should be [6, 1].

Hint: Use the two pointers technique, where both pointers move to the right.
 */
